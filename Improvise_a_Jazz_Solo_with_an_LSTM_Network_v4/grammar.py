{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44cf2429-b873-4d37-a3bc-de2752771e64",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''\n",
    "Author:     Ji-Sung Kim, Evan Chow\n",
    "Project:    jazzml / (used in) deepjazz\n",
    "Purpose:    Extract, manipulate, process musical grammar\n",
    "\n",
    "Directly taken then cleaned up from Evan Chow's jazzml, \n",
    "https://github.com/evancchow/jazzml,with permission.\n",
    "'''\n",
    "\n",
    "from collections import OrderedDict, defaultdict\n",
    "from itertools import groupby\n",
    "from music21 import *\n",
    "import copy, random, pdb\n",
    "\n",
    "#from preprocess import *\n",
    "\n",
    "''' Helper function to determine if a note is a scale tone. '''\n",
    "def __is_scale_tone(chord, note):\n",
    "    # Method: generate all scales that have the chord notes th check if note is\n",
    "    # in names\n",
    "\n",
    "    # Derive major or minor scales (minor if 'other') based on the quality\n",
    "    # of the chord.\n",
    "    scaleType = scale.DorianScale() # i.e. minor pentatonic\n",
    "    if chord.quality == 'major':\n",
    "        scaleType = scale.MajorScale()\n",
    "    # Can change later to deriveAll() for flexibility. If so then use list\n",
    "    # comprehension of form [x for a in b for x in a].\n",
    "    scales = scaleType.derive(chord) # use deriveAll() later for flexibility\n",
    "    allPitches = list(set([pitch for pitch in scales.getPitches()]))\n",
    "    allNoteNames = [i.name for i in allPitches] # octaves don't matter\n",
    "\n",
    "    # Get note name. Return true if in the list of note names.\n",
    "    noteName = note.name\n",
    "    return (noteName in allNoteNames)\n",
    "\n",
    "''' Helper function to determine if a note is an approach tone. '''\n",
    "def __is_approach_tone(chord, note):\n",
    "    # Method: see if note is +/- 1 a chord tone.\n",
    "\n",
    "    for chordPitch in chord.pitches:\n",
    "        stepUp = chordPitch.transpose(1)\n",
    "        stepDown = chordPitch.transpose(-1)\n",
    "        if (note.name == stepDown.name or \n",
    "            note.name == stepDown.getEnharmonic().name or\n",
    "            note.name == stepUp.name or\n",
    "            note.name == stepUp.getEnharmonic().name):\n",
    "                return True\n",
    "    return False\n",
    "\n",
    "''' Helper function to determine if a note is a chord tone. '''\n",
    "def __is_chord_tone(lastChord, note):\n",
    "    return (note.name in (p.name for p in lastChord.pitches))\n",
    "\n",
    "''' Helper function to generate a chord tone. '''\n",
    "def __generate_chord_tone(lastChord):\n",
    "    lastChordNoteNames = [p.nameWithOctave for p in lastChord.pitches]\n",
    "    return note.Note(random.choice(lastChordNoteNames))\n",
    "\n",
    "''' Helper function to generate a scale tone. '''\n",
    "def __generate_scale_tone(lastChord):\n",
    "    # Derive major or minor scales (minor if 'other') based on the quality\n",
    "    # of the lastChord.\n",
    "    scaleType = scale.WeightedHexatonicBlues() # minor pentatonic\n",
    "    if lastChord.quality == 'major':\n",
    "        scaleType = scale.MajorScale()\n",
    "    # Can change later to deriveAll() for flexibility. If so then use list\n",
    "    # comprehension of form [x for a in b for x in a].\n",
    "    scales = scaleType.derive(lastChord) # use deriveAll() later for flexibility\n",
    "    allPitches = list(set([pitch for pitch in scales.getPitches()]))\n",
    "    allNoteNames = [i.name for i in allPitches] # octaves don't matter\n",
    "\n",
    "    # Return a note (no octave here) in a scale that matches the lastChord.\n",
    "    sNoteName = random.choice(allNoteNames)\n",
    "    lastChordSort = lastChord.sortAscending()\n",
    "    sNoteOctave = random.choice([i.octave for i in lastChordSort.pitches])\n",
    "    sNote = note.Note((\"%s%s\" % (sNoteName, sNoteOctave)))\n",
    "    return sNote\n",
    "\n",
    "''' Helper function to generate an approach tone. '''\n",
    "def __generate_approach_tone(lastChord):\n",
    "    sNote = __generate_scale_tone(lastChord)\n",
    "    aNote = sNote.transpose(random.choice([1, -1]))\n",
    "    return aNote\n",
    "\n",
    "''' Helper function to generate a random tone. '''\n",
    "def __generate_arbitrary_tone(lastChord):\n",
    "    return __generate_scale_tone(lastChord) # fix later, make random note.\n",
    "\n",
    "\n",
    "''' Given the notes in a measure ('measure') and the chords in that measure\n",
    "    ('chords'), generate a list of abstract grammatical symbols to represent \n",
    "    that measure as described in GTK's \"Learning Jazz Grammars\" (2009). \n",
    "\n",
    "    Inputs: \n",
    "    1) \"measure\" : a stream.Voice object where each element is a\n",
    "        note.Note or note.Rest object.\n",
    "\n",
    "        >>> m1\n",
    "        <music21.stream.Voice 328482572>\n",
    "        >>> m1[0]\n",
    "        <music21.note.Rest rest>\n",
    "        >>> m1[1]\n",
    "        <music21.note.Note C>\n",
    "\n",
    "        Can have instruments and other elements, removes them here.\n",
    "\n",
    "    2) \"chords\" : a stream.Voice object where each element is a chord.Chord.\n",
    "\n",
    "        >>> c1\n",
    "        <music21.stream.Voice 328497548>\n",
    "        >>> c1[0]\n",
    "        <music21.chord.Chord E-4 G4 C4 B-3 G#2>\n",
    "        >>> c1[1]\n",
    "        <music21.chord.Chord B-3 F4 D4 A3>\n",
    "\n",
    "        Can have instruments and other elements, removes them here. \n",
    "\n",
    "    Outputs:\n",
    "    1) \"fullGrammar\" : a string that holds the abstract grammar for measure.\n",
    "        Format: \n",
    "        (Remember, these are DURATIONS not offsets!)\n",
    "        \"R,0.125\" : a rest element of  (1/32) length, or 1/8 quarter note. \n",
    "        \"C,0.125<M-2,m-6>\" : chord note of (1/32) length, generated\n",
    "                             anywhere from minor 6th down to major 2nd down.\n",
    "                             (interval <a,b> is not ordered). '''\n",
    "\n",
    "def parse_melody(fullMeasureNotes, fullMeasureChords):\n",
    "    # Remove extraneous elements.x\n",
    "    measure = copy.deepcopy(fullMeasureNotes)\n",
    "    chords = copy.deepcopy(fullMeasureChords)\n",
    "    measure.removeByNotOfClass([note.Note, note.Rest])\n",
    "    chords.removeByNotOfClass([chord.Chord])\n",
    "\n",
    "    # Information for the start of the measure.\n",
    "    # 1) measureStartTime: the offset for measure's start, e.g. 476.0.\n",
    "    # 2) measureStartOffset: how long from the measure start to the first element.\n",
    "    measureStartTime = measure[0].offset - (measure[0].offset % 4)\n",
    "    measureStartOffset  = measure[0].offset - measureStartTime\n",
    "\n",
    "    # Iterate over the notes and rests in measure, finding the grammar for each\n",
    "    # note in the measure and adding an abstract grammatical string for it. \n",
    "\n",
    "    fullGrammar = \"\"\n",
    "    prevNote = None # Store previous note. Need for interval.\n",
    "    numNonRests = 0 # Number of non-rest elements. Need for updating prevNote.\n",
    "    for ix, nr in enumerate(measure):\n",
    "        # Get the last chord. If no last chord, then (assuming chords is of length\n",
    "        # >0) shift first chord in chords to the beginning of the measure.\n",
    "        try: \n",
    "            lastChord = [n for n in chords if n.offset <= nr.offset][-1]\n",
    "        except IndexError:\n",
    "            chords[0].offset = measureStartTime\n",
    "            lastChord = [n for n in chords if n.offset <= nr.offset][-1]\n",
    "\n",
    "        # FIRST, get type of note, e.g. R for Rest, C for Chord, etc.\n",
    "        # Dealing with solo notes here. If unexpected chord: still call 'C'.\n",
    "        elementType = ' '\n",
    "        # R: First, check if it's a rest. Clearly a rest --> only one possibility.\n",
    "        if isinstance(nr, note.Rest):\n",
    "            elementType = 'R'\n",
    "        # C: Next, check to see if note pitch is in the last chord.\n",
    "        elif nr.name in lastChord.pitchNames or isinstance(nr, chord.Chord):\n",
    "            elementType = 'C'\n",
    "        # L: (Complement tone) Skip this for now.\n",
    "        # S: Check if it's a scale tone.\n",
    "        elif __is_scale_tone(lastChord, nr):\n",
    "            elementType = 'S'\n",
    "        # A: Check if it's an approach tone, i.e. +-1 halfstep chord tone.\n",
    "        elif __is_approach_tone(lastChord, nr):\n",
    "            elementType = 'A'\n",
    "        # X: Otherwise, it's an arbitrary tone. Generate random note.\n",
    "        else:\n",
    "            elementType = 'X'\n",
    "\n",
    "        # SECOND, get the length for each element. e.g. 8th note = R8, but\n",
    "        # to simplify things you'll use the direct num, e.g. R,0.125\n",
    "        if (ix == (len(measure)-1)):\n",
    "            # formula for a in \"a - b\": start of measure (e.g. 476) + 4\n",
    "            diff = measureStartTime + 4.0 - nr.offset\n",
    "        else:\n",
    "            diff = measure[ix + 1].offset - nr.offset\n",
    "\n",
    "        # Combine into the note info.\n",
    "        noteInfo = \"%s,%.3f\" % (elementType, nr.quarterLength) # back to diff\n",
    "\n",
    "        # THIRD, get the deltas (max range up, max range down) based on where\n",
    "        # the previous note was, +- minor 3. Skip rests (don't affect deltas).\n",
    "        intervalInfo = \"\"\n",
    "        if isinstance(nr, note.Note):\n",
    "            numNonRests += 1\n",
    "            if numNonRests == 1:\n",
    "                prevNote = nr\n",
    "            else:\n",
    "                noteDist = interval.Interval(noteStart=prevNote, noteEnd=nr)\n",
    "                noteDistUpper = interval.add([noteDist, \"m3\"])\n",
    "                noteDistLower = interval.subtract([noteDist, \"m3\"])\n",
    "                intervalInfo = \",<%s,%s>\" % (noteDistUpper.directedName, \n",
    "                    noteDistLower.directedName)\n",
    "                # print \"Upper, lower: %s, %s\" % (noteDistUpper,\n",
    "                #     noteDistLower)\n",
    "                # print \"Upper, lower dnames: %s, %s\" % (\n",
    "                #     noteDistUpper.directedName,\n",
    "                #     noteDistLower.directedName)\n",
    "                # print \"The interval: %s\" % (intervalInfo)\n",
    "                prevNote = nr\n",
    "\n",
    "        # Return. Do lazy evaluation for real-time performance.\n",
    "        grammarTerm = noteInfo + intervalInfo \n",
    "        fullGrammar += (grammarTerm + \" \")\n",
    "\n",
    "    return fullGrammar.rstrip()\n",
    "\n",
    "''' Given a grammar string and chords for a measure, returns measure notes. '''\n",
    "def unparse_grammar(m1_grammar, m1_chords):\n",
    "    m1_elements = stream.Voice()\n",
    "    currOffset = 0.0 # for recalculate last chord.\n",
    "    prevElement = None\n",
    "    for ix, grammarElement in enumerate(m1_grammar.split(' ')):\n",
    "        terms = grammarElement.split(',')\n",
    "        currOffset += float(terms[1]) # works just fine\n",
    "\n",
    "        # Case 1: it's a rest. Just append\n",
    "        if terms[0] == 'R':\n",
    "            rNote = note.Rest(quarterLength = float(terms[1]))\n",
    "            m1_elements.insert(currOffset, rNote)\n",
    "            continue\n",
    "\n",
    "        # Get the last chord first so you can find chord note, scale note, etc.\n",
    "        try: \n",
    "            lastChord = [n for n in m1_chords if n.offset <= currOffset][-1]\n",
    "        except IndexError:\n",
    "            m1_chords[0].offset = 0.0\n",
    "            lastChord = [n for n in m1_chords if n.offset <= currOffset][-1]\n",
    "\n",
    "        # Case: no < > (should just be the first note) so generate from range\n",
    "        # of lowest chord note to highest chord note (if not a chord note, else\n",
    "        # just generate one of the actual chord notes). \n",
    "\n",
    "        # Case #1: if no < > to indicate next note range. Usually this lack of < >\n",
    "        # is for the first note (no precedent), or for rests.\n",
    "        if (len(terms) == 2): # Case 1: if no < >.\n",
    "            insertNote = note.Note() # default is C\n",
    "\n",
    "            # Case C: chord note.\n",
    "            if terms[0] == 'C':\n",
    "                insertNote = __generate_chord_tone(lastChord)\n",
    "\n",
    "            # Case S: scale note.\n",
    "            elif terms[0] == 'S':\n",
    "                insertNote = __generate_scale_tone(lastChord)\n",
    "\n",
    "            # Case A: approach note.\n",
    "            # Handle both A and X notes here for now.\n",
    "            else:\n",
    "                insertNote = __generate_approach_tone(lastChord)\n",
    "\n",
    "            # Update the stream of generated notes\n",
    "            insertNote.quarterLength = float(terms[1])\n",
    "            if insertNote.octave < 4:\n",
    "                insertNote.octave = 4\n",
    "            m1_elements.insert(currOffset, insertNote)\n",
    "            prevElement = insertNote\n",
    "\n",
    "        # Case #2: if < > for the increment. Usually for notes after the first one.\n",
    "        else:\n",
    "            # Get lower, upper intervals and notes.\n",
    "            interval1 = interval.Interval(terms[2].replace(\"<\",''))\n",
    "            interval2 = interval.Interval(terms[3].replace(\">\",''))\n",
    "            if interval1.cents > interval2.cents:\n",
    "                upperInterval, lowerInterval = interval1, interval2\n",
    "            else:\n",
    "                upperInterval, lowerInterval = interval2, interval1\n",
    "            lowPitch = interval.transposePitch(prevElement.pitch, lowerInterval)\n",
    "            highPitch = interval.transposePitch(prevElement.pitch, upperInterval)\n",
    "            numNotes = int(highPitch.ps - lowPitch.ps + 1) # for range(s, e)\n",
    "\n",
    "            # Case C: chord note, must be within increment (terms[2]).\n",
    "            # First, transpose note with lowerInterval to get note that is\n",
    "            # the lower bound. Then iterate over, and find valid notes. Then\n",
    "            # choose randomly from those.\n",
    "            \n",
    "            if terms[0] == 'C':\n",
    "                relevantChordTones = []\n",
    "                for i in range(0, numNotes):\n",
    "                    currNote = note.Note(lowPitch.transpose(i).simplifyEnharmonic())\n",
    "                    if __is_chord_tone(lastChord, currNote):\n",
    "                        relevantChordTones.append(currNote)\n",
    "                if len(relevantChordTones) > 1:\n",
    "                    insertNote = random.choice([i for i in relevantChordTones\n",
    "                        if i.nameWithOctave != prevElement.nameWithOctave])\n",
    "                elif len(relevantChordTones) == 1:\n",
    "                    insertNote = relevantChordTones[0]\n",
    "                else: # if no choices, set to prev element +-1 whole step\n",
    "                    insertNote = prevElement.transpose(random.choice([-2,2]))\n",
    "                if insertNote.octave < 3:\n",
    "                    insertNote.octave = 3\n",
    "                insertNote.quarterLength = float(terms[1])\n",
    "                m1_elements.insert(currOffset, insertNote)\n",
    "\n",
    "            # Case S: scale note, must be within increment.\n",
    "            elif terms[0] == 'S':\n",
    "                relevantScaleTones = []\n",
    "                for i in range(0, numNotes):\n",
    "                    currNote = note.Note(lowPitch.transpose(i).simplifyEnharmonic())\n",
    "                    if __is_scale_tone(lastChord, currNote):\n",
    "                        relevantScaleTones.append(currNote)\n",
    "                if len(relevantScaleTones) > 1:\n",
    "                    insertNote = random.choice([i for i in relevantScaleTones\n",
    "                        if i.nameWithOctave != prevElement.nameWithOctave])\n",
    "                elif len(relevantScaleTones) == 1:\n",
    "                    insertNote = relevantScaleTones[0]\n",
    "                else: # if no choices, set to prev element +-1 whole step\n",
    "                    insertNote = prevElement.transpose(random.choice([-2,2]))\n",
    "                if insertNote.octave < 3:\n",
    "                    insertNote.octave = 3\n",
    "                insertNote.quarterLength = float(terms[1])\n",
    "                m1_elements.insert(currOffset, insertNote)\n",
    "\n",
    "            # Case A: approach tone, must be within increment.\n",
    "            # For now: handle both A and X cases.\n",
    "            else:\n",
    "                relevantApproachTones = []\n",
    "                for i in range(0, numNotes):\n",
    "                    currNote = note.Note(lowPitch.transpose(i).simplifyEnharmonic())\n",
    "                    if __is_approach_tone(lastChord, currNote):\n",
    "                        relevantApproachTones.append(currNote)\n",
    "                if len(relevantApproachTones) > 1:\n",
    "                    insertNote = random.choice([i for i in relevantApproachTones\n",
    "                        if i.nameWithOctave != prevElement.nameWithOctave])\n",
    "                elif len(relevantApproachTones) == 1:\n",
    "                    insertNote = relevantApproachTones[0]\n",
    "                else: # if no choices, set to prev element +-1 whole step\n",
    "                    insertNote = prevElement.transpose(random.choice([-2,2]))\n",
    "                if insertNote.octave < 3:\n",
    "                    insertNote.octave = 3\n",
    "                insertNote.quarterLength = float(terms[1])\n",
    "                m1_elements.insert(currOffset, insertNote)\n",
    "\n",
    "            # update the previous element.\n",
    "            prevElement = insertNote\n",
    "\n",
    "    return m1_elements    \n",
    "   "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
