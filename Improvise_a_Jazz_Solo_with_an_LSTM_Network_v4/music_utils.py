{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c550b7c9-017d-48ea-bc82-b54bebe62cb2",
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import print_function\n",
    "import tensorflow as tf\n",
    "#import tensorflow.keras.backend as K\n",
    "from tensorflow.keras.layers import RepeatVector\n",
    "import sys\n",
    "from music21 import *\n",
    "import numpy as np\n",
    "from grammar import *\n",
    "from preprocess import *\n",
    "from qa import *\n",
    "\n",
    "\n",
    "def data_processing(corpus, values_indices, m = 60, Tx = 30):\n",
    "    # cut the corpus into semi-redundant sequences of Tx values\n",
    "    Tx = Tx \n",
    "    N_values = len(set(corpus))\n",
    "    np.random.seed(0)\n",
    "    X = np.zeros((m, Tx, N_values), dtype=np.bool)\n",
    "    Y = np.zeros((m, Tx, N_values), dtype=np.bool)\n",
    "    for i in range(m):\n",
    "#         for t in range(1, Tx):\n",
    "        random_idx = np.random.choice(len(corpus) - Tx)\n",
    "        corp_data = corpus[random_idx:(random_idx + Tx)]\n",
    "        for j in range(Tx):\n",
    "            idx = values_indices[corp_data[j]]\n",
    "            if j != 0:\n",
    "                X[i, j, idx] = 1\n",
    "                Y[i, j-1, idx] = 1\n",
    "    \n",
    "    Y = np.swapaxes(Y,0,1)\n",
    "    Y = Y.tolist()\n",
    "    return np.asarray(X), np.asarray(Y), N_values \n",
    "\n",
    "def next_value_processing(model, next_value, x, predict_and_sample, indices_values, abstract_grammars, duration, max_tries = 1000, temperature = 0.5):\n",
    "    \"\"\"\n",
    "    Helper function to fix the first value.\n",
    "    \n",
    "    Arguments:\n",
    "    next_value -- predicted and sampled value, index between 0 and 77\n",
    "    x -- numpy-array, one-hot encoding of next_value\n",
    "    predict_and_sample -- predict function\n",
    "    indices_values -- a python dictionary mapping indices (0-77) into their corresponding unique value (ex: A,0.250,< m2,P-4 >)\n",
    "    abstract_grammars -- list of grammars, on element can be: 'S,0.250,<m2,P-4> C,0.250,<P4,m-2> A,0.250,<P4,m-2>'\n",
    "    duration -- scalar, index of the loop in the parent function\n",
    "    max_tries -- Maximum numbers of time trying to fix the value\n",
    "    \n",
    "    Returns:\n",
    "    next_value -- process predicted value\n",
    "    \"\"\"\n",
    "\n",
    "    # fix first note: must not have < > and not be a rest\n",
    "    if (duration < 0.00001):\n",
    "        tries = 0\n",
    "        while (next_value.split(',')[0] == 'R' or \n",
    "            len(next_value.split(',')) != 2):\n",
    "            # give up after 1000 tries; random from input's first notes\n",
    "            if tries >= max_tries:\n",
    "                #print('Gave up on first note generation after', max_tries, 'tries')\n",
    "                # np.random is exclusive to high\n",
    "                rand = np.random.randint(0, len(abstract_grammars))\n",
    "                next_value = abstract_grammars[rand].split(' ')[0]\n",
    "            else:\n",
    "                next_value = predict_and_sample(model, x, indices_values, temperature)\n",
    "\n",
    "            tries += 1\n",
    "            \n",
    "    return next_value\n",
    "\n",
    "\n",
    "def sequence_to_matrix(sequence, values_indices):\n",
    "    \"\"\"\n",
    "    Convert a sequence (slice of the corpus) into a matrix (numpy) of one-hot vectors corresponding \n",
    "    to indices in values_indices\n",
    "    \n",
    "    Arguments:\n",
    "    sequence -- python list\n",
    "    \n",
    "    Returns:\n",
    "    x -- numpy-array of one-hot vectors \n",
    "    \"\"\"\n",
    "    sequence_len = len(sequence)\n",
    "    x = np.zeros((1, sequence_len, len(values_indices)))\n",
    "    for t, value in enumerate(sequence):\n",
    "        if (not value in values_indices): print(value)\n",
    "        x[0, t, values_indices[value]] = 1.\n",
    "    return x\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
